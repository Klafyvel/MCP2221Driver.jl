var documenterSearchIndex = {"docs":
[{"location":"lowlevel/tutorial/#Low-Level-API-Tutorial","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"This tutorial aims at guiding you through the basic usage of the Low-Level API.  In case of doubts, please refer to the chip's documentation. It assumes that you have a MCP2221A device connected through the USB.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"warning: Follow at your own risks\nWhen dealing with hardware components and USB devices, it is possible to  damage your computer or your devices. It is also possible to brick your device (especially if you use the password settings of the MCP2221A). While I have tested this tutorial at the time of writing it, I decline all responsibilities for what may happen if you follow it. Use at your own risks!","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 4","category":"page"},{"location":"lowlevel/tutorial/#Connecting-to-the-hardware","page":"Low-Level API Tutorial","title":"Connecting to the hardware","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The Low-Level API expects you to provide a device to which it can talk to. In this tutorial, we are going to use HidApi.jl to connect to and handle the USB communications to the hardware. You can install it using:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> import Pkg\njulia> Pkg.add(\"HidApi\")","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"HidApi.jl requires initialization before it lets us enumerate devices:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> using MCP2221Driver\n\njulia> import HidApi\n\njulia> HidApi.init()\n\njulia> devices = HidApi.enumerate_devices()\n2-element Vector{HidDevice}:\n HidDevice(\"1-1:1.2\", 0x04d8, 0x00dd, \"\", 0x0100, \"\", \"\", 0x0000, 0x0000, 2, Ptr{HidApi.hid_device_} @0x0000000000000000, HidApi.hid_device_info(Ptr{Int8} @0x0000000004cccfa0, 0x04d8, 0x00dd, Ptr{Nothing} @0x0000000000000000, 0x0100, Ptr{Nothing} @0x0000000000000000, Ptr{Nothing} @0x0000000000000000, 0x0000, 0x0000, 2, Ptr{HidApi.hid_device_info} @0x0000000004312c60, HidApi.HID_API_BUS_USB))\n... Other devices if some are present.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"For this tutorial, I am using a brand new MCP2221A that hasn't been used yet. The chip's documentation gives the default Vendor ID (0x04D8) and Product ID (0x00DD). They can also be found in MCP2221Driver.MCP2221A_DEFAULT_VID and MCP2221Driver.MCP2221A_DEFAULT_PID. ","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"note: Linux users and permissions\nAt this point, Linux users may not be able to connect to their device. You can fix this by creating a udev rule for our MCP2221A chip. For example, the following rule (to be added in file /etc/udev/rules.d/50-mcp2221a-tutorial.rules) will allow you to connect to the chip:SUBSYSTEM==\"usb\", ATTR{idVendor}==\"04d8\", ATTR{idProduct}==\"00dd\", MODE:=\"0666\"Then, you can reload udev rules and trigger them with sudo udevadm control --reload-rules\nsudo udevadm triggerBe aware that you will need to repeat the operation later-on if you change the Vendor ID or Product ID of the chip. ","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We can connect using HidApi.jl's find_device function.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> device = open(HidApi.find_device(MCP2221Driver.MCP2221A_DEFAULT_VID, MCP2221Driver.MCP2221A_DEFAULT_PID))\nVendor/Product ID : 0x04d8 / 0x00dd\n             Path : 1-1:1.2\n          Product : MCP2221 USB-I2C/UART Combo\n    Serial number : \n     Manufacturer : Microchip Technology Inc.\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"note: Leaving properly\nRemember to close the device and HidApi.jl when you leave the REPL to avoid running into problems!julia> close(device)\nVendor/Product ID : 0x04d8 / 0x00dd\n             Path : 1-1:1.2\n          Product : MCP2221 USB-I2C/UART Combo\n    Serial number : \n     Manufacturer : Microchip Technology Inc.\n\njulia> HidApi.shutdown()","category":"page"},{"location":"lowlevel/tutorial/#Some-simple-queries","page":"Low-Level API Tutorial","title":"Some simple queries","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"At this stage, you should have your device loaded in the REPL and open. We can start by querying the current state of the chip. To do so, we use the MCP2221Driver.StatusSetParametersCommand command:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.StatusSetParametersCommand(false, 0x00)\nMCP2221Driver.StatusSetParametersCommand(false, 0)\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.StatusSetParametersResponse(MCP2221Driver.Success, MCP2221Driver.NoSpecialOperation, MCP2221Driver.NoSetSpeed, 0x00, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x0000, false, 0x01, 0x01, false, 0x00, v\"65.54.0\", v\"49.50.0\", 0x03ff, 0x0000, 0x0300)","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The chip gives us a set of its current parameters. Refer to MCP2221Driver.StatusSetParametersResponse's documentation to get their meaning. For example, one can see that my chip uses the following hardware and firmware versions:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> response.hardwareversion\nv\"65.54.0\"\n\njulia> response.firmwareversion\nv\"49.50.0\"","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"Refer to the Low-Level API Reference to get a list of available commands. For example, we can query the current state of the GPIO pins:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetGPIOValuesCommand()\nMCP2221Driver.GetGPIOValuesCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetGPIOValuesResponse(MCP2221Driver.Success, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"MCP2221Driver.GetGPIOValuesResponse tells us that all these nothing means that none of the GPIO pin is configured to be used as a GPIO. Indeed, if we query the current SRAM settings, we get:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput12MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVDD, 0x08, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation))\n\njulia> response.gpio0status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0)\n\njulia> response.gpio1status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1)\n\njulia> response.gpio2status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)\n\njulia> response.gpio3status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"All GPIO pins are dedicated to functions other than GPIO operations. See MCP2221Driver.GPDesignation for the meaning of these.","category":"page"},{"location":"lowlevel/tutorial/#Chip-settings","page":"Low-Level API Tutorial","title":"Chip settings","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We have already used MCP2221Driver.GetSRAMSettingsCommand to query the currently loaded settings. At boot, the MCP2221A loads the settings present in flash memory to SRAM. We can confirm that both flash settings and SRAM settings match. Note that flash memory settings are separated in several commands, see the Flash Memory Manipulation section of the Low-Level API Reference for a list.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.ReadFlashDataChipSettingsCommand()\nMCP2221Driver.ReadFlashDataChipSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.ReadFlashDataChipSettingsResponse(MCP2221Driver.Success, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput12MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVDD, 0x08, true, true, MCP2221Driver.Reference4p096, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"For example, the current clock output setting is set for 12 MHz output:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command);\n\njulia> response.clockoutputdividervalue\nClockOutput12MHz::ClockOutputFrequency = 0x02","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We can change that using MCP2221Driver.SetSRAMSettingsCommand:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.SetSRAMSettingsCommand(clockoutputsettings=(duty=MCP2221Driver.ClockOutputDuty50, dividervalue=MCP2221Driver.ClockOutput3MHz))\nMCP2221Driver.SetSRAMSettingsCommand((duty = MCP2221Driver.ClockOutputDuty50, dividervalue = MCP2221Driver.ClockOutput3MHz), nothing, nothing, nothing, nothing, nothing, false, nothing)\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We can check that the clock output frequency has indeed been modified:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command);\n\njulia> response.clockoutputdividervalue\nClockOutput3MHz::ClockOutputFrequency = 0x04\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"However, if you power-down your device, this modification gets erased:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> close(device)\nVendor/Product ID : 0x04d8 / 0x00dd\n             Path : 1-1:1.2\n          Product : MCP2221 USB-I2C/UART Combo\n    Serial number : \n     Manufacturer : Microchip Technology Inc.\n\n# Here, un-plug then re-plug the USB\n\njulia> device = open(find_device(MCP2221Driver.MCP2221A_DEFAULT_VID, MCP2221Driver.MCP2221A_DEFAULT_PID))\nVendor/Product ID : 0x04d8 / 0x00dd\n             Path : 1-1:1.2\n          Product : MCP2221 USB-I2C/UART Combo\n    Serial number : \n     Manufacturer : Microchip Technology Inc.\n\njulia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput12MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVDD, 0x08, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation))\n\njulia> response.clockoutputdividervalue\nClockOutput12MHz::ClockOutputFrequency = 0x02","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"To make te change persistent after reboots, one needs to write this into flash memory. This is a bit tedious to do with the low-level API, as you need to re-send all the other parameters affected by the flash writing command you use.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command);\n\njulia> command = MCP2221Driver.WriteFlashDataChipSettingsCommand(\n       response.cdcserialnumberenumerationenable,\n       response.chipconfigurationsecurityoption,\n       response.clockoutputduty,\n       MCP2221Driver.ClockOutput3MHz,\n       response.dacreferencevoltage,\n       response.dacreferenceoption,\n       response.powerupdacvalue,\n       response.interruptdetectionnegativeedge,\n       response.interruptdetectionpositiveedge,\n       response.adcreferencevoltage,\n       response.adcreferenceoption,\n       response.vid,\n       response.pid,\n       response.usbpowerattributes,\n       response.usbrequestednumberofma,\n       \"\"\n       )\nMCP2221Driver.WriteFlashDataChipSettingsCommand(false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVDD, 0x08, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\")\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"note: Password protection\nPlease, note that here the device is not password-protected, hence I can supply an empty password as the last parameter of the command. Please refer to the chip manual and the Low-Level API Reference concerning password protection.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"If you now close the device (close(device)), un-plug and re-plug it, then do:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> device = open(find_device(MCP2221Driver.MCP2221A_DEFAULT_VID, MCP2221Driver.MCP2221A_DEFAULT_PID))\nVendor/Product ID : 0x04d8 / 0x00dd\n             Path : 1-1:1.2\n          Product : MCP2221 USB-I2C/UART Combo\n    Serial number : \n     Manufacturer : Microchip Technology Inc.\n\njulia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command);\n\njulia> response.clockoutputdividervalue\nClockOutput3MHz::ClockOutputFrequency = 0x04\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"You can see that we have made the change persistent!","category":"page"},{"location":"lowlevel/tutorial/#GPIO-Operations","page":"Low-Level API Tutorial","title":"GPIO Operations","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"In this section, we illustrate the use GPIO pins 2 and 3 to write a \"blink\" program.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The first step is to configure the two pins as outputs. We will also set their output value to 0. This is done with the MCP2221Driver.SetSRAMSettingsCommand command. We have to send configuration for all four GP pins, so we first retrieve the configuration for the two other pins.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVRM, 0x00, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation))\n\njulia> response.gpio2status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)\n\njulia> response.gpio3status\nMCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)\n\njulia> command = MCP2221Driver.SetSRAMSettingsCommand(gpiosettings=(gpio0=response.gpio0status, gpio1=response.gpio1status, gpio2=MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation), gpio3=MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation)))\nMCP2221Driver.SetSRAMSettingsCommand(nothing, nothing, nothing, nothing, nothing, nothing, false, (gpio0 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), gpio1 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), gpio2 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation), gpio3 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation)))\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We could keep using the same command to make the outputs blink, but we can also make use of the MCP2221Driver.SetGPIOOutputValuesCommand to avoid having to re-send the configuration of the other pins. It is then a simple matter of looping through the values. If you have LEDs connected to GP pins 2 and 3 (don't forget to put resistors!), the following code will make them blink alternatively for one minute.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> for i in 1:60\n           command = MCP2221Driver.SetGPIOOutputValuesCommand(gp2outputvalue=isodd(i), gp3outputvalue=iseven(i))\n           MCP2221Driver.query(device, command)\n           sleep(1)\n       end\n","category":"page"},{"location":"lowlevel/tutorial/#Analog-IO","page":"Low-Level API Tutorial","title":"Analog IO","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"GP pins 2 and 3 are also connected to the Digital-to-Analog Converter (DAC) outputs. This means we can use them tom produce analog tensions. In this section, we will use the DAC to produce a sine wave on GP pin 2 (a \"smooth blink\"). ","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"note: A single DAC per chip\nThe MCP2221A only possesses one DAC, but both GP2 and GP3 can use it. If you configure both pins to use the DAC, they will present the same output.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The first step is to configure GP2 to use the DAC. This is pretty similar to what we did in the previous section.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVRM, 0x00, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation))\n\njulia> command = MCP2221Driver.SetSRAMSettingsCommand(gpiosettings=(gpio0=response.gpio0status, gpio1=response.gpio1status, gpio2=MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), gpio3=response.gpio3status))\nMCP2221Driver.SetSRAMSettingsCommand(nothing, nothing, nothing, nothing, nothing, nothing, false, (gpio0 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), gpio1 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), gpio2 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), gpio3 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation)))\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The DAC is accessed through AlternateFunction1 for GP2. See MCP2221Driver.GPDesignation. All DAC settings are set through MCP2221Driver.SetSRAMSettingsCommand. First, I will set the DAC to use the internal reference at 4.096V (see also Analog to Digital / Ditital to Analog conversion for options).","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"\njulia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVRM, 0x00, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation))\n\njulia> response.dacreferencevoltage\nReference2p048::ReferenceVoltageOption = 0x02\n\njulia> response.dacreferenceoption\nSourceReferenceVRM::SourceReferenceOption = 0\n\njulia> command = MCP2221Driver.SetSRAMSettingsCommand(dacsettings=(referencevoltage=MCP2221Driver.Reference4p096, referenceoption=MCP2221Driver.SourceReferenceVRM))\nMCP2221Driver.SetSRAMSettingsCommand(nothing, (referencevoltage = MCP2221Driver.Reference4p096, referenceoption = MCP2221Driver.SourceReferenceVRM), nothing, nothing, nothing, nothing, false, nothing)\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference4p096, MCP2221Driver.SourceReferenceVRM, 0x00, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation))\n\njulia> response.dacreferencevoltage\nReference4p096::ReferenceVoltageOption = 0x03\n\njulia> response.dacreferenceoption\nSourceReferenceVRM::SourceReferenceOption = 0x01\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"We can now use the 5-bits DAC to generate a smooth blinking of the LED I have attached to GP2.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> ys = @. round(UInt8, 31*(sin(2π*2*(1:0.1:60))/2 + 1))\n591-element Vector{UInt8}:\n 0x1f\n 0x2e\n 0x28\n 0x16\n 0x10\n 0x1f\n 0x2e\n 0x28\n 0x16\n 0x10\n    ⋮\n 0x2e\n 0x28\n 0x16\n 0x10\n 0x1f\n 0x2e\n 0x28\n 0x16\n 0x10\n 0x1f\n\njulia> for y in ys\n           command = MCP2221Driver.SetSRAMSettingsCommand(dacoutputvalue=y)\n           MCP2221Driver.query(device, command)\n           sleep(0.1)\n       end\n","category":"page"},{"location":"lowlevel/tutorial/#IC-Operations","page":"Low-Level API Tutorial","title":"I²C Operations","text":"","category":"section"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The MCP2221A is equiped with an I²C module that we can use to talk to other devices. In this section, we will illustrate these capabilities by communication with a TMP117 digital thermometer available at address 0x48.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"First, we can configure GP2 and GP3 to display the USB configured and USB/I²C traffic inficators respectively.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetSRAMSettingsCommand()\nMCP2221Driver.GetSRAMSettingsCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetSRAMSettingsResponse(MCP2221Driver.Success, 0x12, 0x04, false, MCP2221Driver.Unsecured, MCP2221Driver.ClockOutputDuty50, MCP2221Driver.ClockOutput3MHz, MCP2221Driver.Reference2p048, MCP2221Driver.SourceReferenceVRM, 0x00, true, true, MCP2221Driver.Reference1p024, MCP2221Driver.SourceReferenceVDD, 0x04d8, 0x00dd, 0x80, 0x32, \"\\0\\0\\0\\0\\0\\0\\0\\0\", MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation), MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.GPIOOperation))\n\njulia> command = MCP2221Driver.SetSRAMSettingsCommand(gpiosettings=(gpio0=response.gpio0status, gpio1=response.gpio1status, gpio2=MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation), gpio3=MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)))\nMCP2221Driver.SetSRAMSettingsCommand(nothing, nothing, nothing, nothing, nothing, nothing, false, (gpio0 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction0), gpio1 = MCP2221Driver.GPIOStatus(true, MCP2221Driver.GPIOOutput, MCP2221Driver.AlternateFunction1), gpio2 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation), gpio3 = MCP2221Driver.GPIOStatus(false, MCP2221Driver.GPIOOutput, MCP2221Driver.DedicatedFunctionOperation)))\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"The thermometer is available at address 0x48. MCP2221Driver.jl provides the MCP2221Driver.I2CAddress abstraction to represent addresses.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> thermometer_address = MCP2221Driver.I2CAddress(0x48)\nMCP2221Driver.I2CAddress(0x48)","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"To read values from the thermometer, you can first write a register address to the pointer register, and then generate a START condition and send the thermometer address byte and the read bit high to initiate the reading. Fortunately, you do not need to know these details of the I²C protocol to perform this. Using the low-level API, you can proceed as follow.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"First, let's read the last temperature measurement from the Temp_Result register at register address 00.  First, we set the pointer register to address 00: ","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.I2CWriteDataCommand(thermometer_address, MCP2221Driver.I2CSingle, [0x00])\nMCP2221Driver.I2CWriteDataCommand(MCP2221Driver.I2CAddress(0x48), MCP2221Driver.I2CSingle, UInt8[0x00])\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"Then, we order the I²C module to read the currently pointed register from the thermometer:","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.I2CReadDataCommand(thermometer_address, MCP2221Driver.I2CSingle, 2)\n\nMCP2221Driver.I2CReadDataCommand(MCP2221Driver.I2CAddress(0x48), MCP2221Driver.I2CSingle, 0x0002)\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GenericResponse(MCP2221Driver.Success)\n","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"Finally, we read the value from the driver's internal memory and convert it to a sensible unit.","category":"page"},{"location":"lowlevel/tutorial/","page":"Low-Level API Tutorial","title":"Low-Level API Tutorial","text":"julia> command = MCP2221Driver.GetI2CDataCommand()\nMCP2221Driver.GetI2CDataCommand()\n\njulia> response = MCP2221Driver.query(device, command)\nMCP2221Driver.GetI2CDataResponse(MCP2221Driver.Success, UInt8[0x0c, 0x9e])\n\njulia> temperature = 7.8125e-3 * ntoh(first(reinterpret(UInt16, response.data)))\n25.234375\n\njulia> println(\"Temperature is $(temperature)°C.\")\nTemperature is 25.234375°C.\n","category":"page"},{"location":"lowlevel/internal/#Low-Level-API-internals","page":"Low-Level API internals","title":"Low-Level API internals","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"Pages = [\"internal.md\"]\nDepth = 4","category":"page"},{"location":"lowlevel/internal/#Communication-protocol-specification","page":"Low-Level API internals","title":"Communication protocol specification","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"The whole goal of the Low-Level API is to bridge the chip's protocol to arrays of bytes that can be sent through the USB. The protocol is specified using Julia's type system. This means that the API defines a set of commands that correspond to the chip's (sub-)commands[subcommands]. The conversion to Vector{UInt8} is done by MCP2221Driver.asarray. It initializes a 64-bytes long vector and populates the two first items using MCP2221Driver.commandcode and MCP2221Driver.subcommandcode. The array is then mutated by MCP2221Driver.initarray! to correspond to the chip's specification. This allows overwriting the sub-command item for commands that do not support sub-commands (for example, MCP2221Driver.I2CWriteDataCommand).","category":"page"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"The specification of the protocol through the type-system gives the type-stability of MCP2221Driver.query. Indeed, since MCP2221Driver.expectsresponse and MCP2221Driver.responsetype are defined for each command types, the compiler knows what to expect as a response (nothing when expectsresponse(T) is false, responsetype(T) otherwise).","category":"page"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"[subcommands]: The chip's flash memory access commands define a set of sub-commands. For simplicity, the Low-Level API maps those as normal commands and handles internally the conversion to sub-commands. Some commands have also been grouped, such as the I²C writing commands.","category":"page"},{"location":"lowlevel/internal/#Low-Level-API-internals-Reference","page":"Low-Level API internals","title":"Low-Level API internals Reference","text":"","category":"section"},{"location":"lowlevel/internal/#Commands-and-Responses","page":"Low-Level API internals","title":"Commands and Responses","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"MCP2221Driver.AbstractCommand\nMCP2221Driver.AbstractResponse","category":"page"},{"location":"lowlevel/internal/#MCP2221Driver.AbstractCommand","page":"Low-Level API internals","title":"MCP2221Driver.AbstractCommand","text":"All mid-level commands inherit from AbstractCommand. Commands should satisfy the mid-level command interface.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/internal/#MCP2221Driver.AbstractResponse","page":"Low-Level API internals","title":"MCP2221Driver.AbstractResponse","text":"All mid-level responses inherit from AbstractResponse. Responses should be able  to build from an array of 64 UInt8.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/internal/#midlevel_command_interface","page":"Low-Level API internals","title":"Command interface","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"MCP2221Driver.asarray\nMCP2221Driver.commandcode\nMCP2221Driver.subcommandcode\nMCP2221Driver.responsetype\nMCP2221Driver.expectsresponse\nMCP2221Driver.initarray!","category":"page"},{"location":"lowlevel/internal/#MCP2221Driver.asarray","page":"Low-Level API internals","title":"MCP2221Driver.asarray","text":"asarray(command)\n\nBuild a 64-long Vector{UInt8} from the given command.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.commandcode","page":"Low-Level API internals","title":"MCP2221Driver.commandcode","text":"commandcode(::T) where {T<:AbstractCommand} ::UInt8\n\nReturn the first byte of a command sequence, identifying the command.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.subcommandcode","page":"Low-Level API internals","title":"MCP2221Driver.subcommandcode","text":"subcommandcode(::T) where {T<:AbstractCommand} ::UInt8\n\nReturn the second byte of a command sequence, identifying the sub-command. Defaults to 0.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.responsetype","page":"Low-Level API internals","title":"MCP2221Driver.responsetype","text":"responsetype(::Type{T}) where {T<:AbstractCommand}::Type{<:AbstractResponse}\n\nReturn the expected type of the command. It must me defined if expectsresponse returns true for type T.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.expectsresponse","page":"Low-Level API internals","title":"MCP2221Driver.expectsresponse","text":"expectsresponse(::Type{T}) where {T<:AbstractCommand}::Bool\n\nIf true, read a response of type responsetype(T) from the device. Defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.initarray!","page":"Low-Level API internals","title":"MCP2221Driver.initarray!","text":"initarray!(command, v)\n\nInitialize the array v given a command. The command does not have to handle the two first bytes. It assumes v elements are all zero.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#Utilities","page":"Low-Level API internals","title":"Utilities","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"MCP2221Driver.ByteStringIterator\nMCP2221Driver.CommandSummary\nMCP2221Driver.writeaddress\nMCP2221Driver.readaddress","category":"page"},{"location":"lowlevel/internal/#MCP2221Driver.ByteStringIterator","page":"Low-Level API internals","title":"MCP2221Driver.ByteStringIterator","text":"Produces bytes associated to a string, with at least L bytes per character. If it is strict, then each character will be exactly L bytes, regardless of correctness.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/internal/#MCP2221Driver.CommandSummary","page":"Low-Level API internals","title":"MCP2221Driver.CommandSummary","text":"Internal type used to make DocStringExtensions.jl document the link between commands and reponses. Use with the COMMANDSUMMARY abbreviation.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/internal/#MCP2221Driver.writeaddress","page":"Low-Level API internals","title":"MCP2221Driver.writeaddress","text":"Format an address for a write command according to MCP2221's specification. \n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#MCP2221Driver.readaddress","page":"Low-Level API internals","title":"MCP2221Driver.readaddress","text":"Format an address for a read command according to MCP2221's specification. \n\n\n\n\n\n","category":"function"},{"location":"lowlevel/internal/#Index","page":"Low-Level API internals","title":"Index","text":"","category":"section"},{"location":"lowlevel/internal/","page":"Low-Level API internals","title":"Low-Level API internals","text":"Pages   = [\"internal.md\"]","category":"page"},{"location":"lowlevel/reference/#Low-Level-API-Reference","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"The Low-Level API commands mostly map to the HID commands supported by the chip. In case of doubts, please refer to the chip's documentation.","category":"page"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"Pages = [\"reference.md\"]\nDepth = 4","category":"page"},{"location":"lowlevel/reference/#Summary-of-commands-and-responses.","page":"Low-Level API Reference","title":"Summary of commands and responses.","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"using AbstractTrees\nusing InteractiveUtils: subtypes, supertype\nusing Markdown\nusing MCP2221Driver\nstruct TypeTree\n    t::Type\nend\nfunction AbstractTrees.children(t::TypeTree)\n    return t.t === Function ? Vector{TypeTree}() : map(x -> TypeTree(x), filter(x -> x !== Any, subtypes(t.t)))\nend\nAbstractTrees.printnode(io::IO, t::TypeTree) = print(io, t.t)\nAbstractTrees.nodevalue(t::TypeTree) = t.t\nAbstractTrees.parent(t::TypeTree) = TypeTree(supertype(t.t))\nAbstractTrees.ParentLinks(::Type{TypeTree}) = StoredParents()\n\nformattypename(t) = last(split(string(t), \".\"))\n\nbuf = IOBuffer()\n\nprintln(buf)\nprintln(buf, \"| Command | Response |\")\nprintln(buf, \"| -------:|:-------- |\")\nfor node in AbstractTrees.PreOrderDFS(TypeTree(MCP2221Driver.AbstractCommand))\n    t = nodevalue(node)\n    if !isabstracttype(t)\n        print(buf, \"| [`$(formattypename(t))`](#$t) | \")\n        if MCP2221Driver.expectsresponse(t)\n            resp = MCP2221Driver.responsetype(t)\n            print(buf, \"[`$(formattypename(resp))`](#$resp)\")\n        else\n            print(buf, \"No response.\")\n        end\n        println(buf, \" |\")\n    end\nend \nMarkdown.parse(String(take!(buf)))","category":"page"},{"location":"lowlevel/reference/#Constants","page":"Low-Level API Reference","title":"Constants","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.HID_MESSAGE_LENGTH\nMCP2221Driver.MCP2221A_DEFAULT_VID\nMCP2221Driver.MCP2221A_DEFAULT_PID","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.HID_MESSAGE_LENGTH","page":"Low-Level API Reference","title":"MCP2221Driver.HID_MESSAGE_LENGTH","text":"Length in bytes of HID communcations.\n\n\n\n\n\n","category":"constant"},{"location":"lowlevel/reference/#MCP2221Driver.MCP2221A_DEFAULT_VID","page":"Low-Level API Reference","title":"MCP2221Driver.MCP2221A_DEFAULT_VID","text":"MCP2221A default Vendor ID (VID), as per documentation.\n\n\n\n\n\n","category":"constant"},{"location":"lowlevel/reference/#MCP2221Driver.MCP2221A_DEFAULT_PID","page":"Low-Level API Reference","title":"MCP2221Driver.MCP2221A_DEFAULT_PID","text":"MCP2221A default Product ID (PID), as per documentation.\n\n\n\n\n\n","category":"constant"},{"location":"lowlevel/reference/#Enumerations-and-Utility-Structures","page":"Low-Level API Reference","title":"Enumerations and Utility Structures","text":"","category":"section"},{"location":"lowlevel/reference/#Communication-protocol","page":"Low-Level API Reference","title":"Communication protocol","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.ResponseStatus\nMCP2221Driver.ChipConfigurationSecurityOption","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.ResponseStatus","page":"Low-Level API Reference","title":"MCP2221Driver.ResponseStatus","text":"Status flag for a response.\n\nSuccess: command succeded,\nI2CBusy: \nCommandNotSupported: Command not supported,\nCOmmandNotAllowed: Command not allowed.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ChipConfigurationSecurityOption","page":"Low-Level API Reference","title":"MCP2221Driver.ChipConfigurationSecurityOption","text":"Chip security configuration option:\n\nPermanentlyLocked\nPasswordProtected\nUnsecured\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#Analog-to-Digital-/-Ditital-to-Analog-conversion","page":"Low-Level API Reference","title":"Analog to Digital / Ditital to Analog conversion","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.ReferenceVoltageOption\nMCP2221Driver.SourceReferenceOption","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.ReferenceVoltageOption","page":"Low-Level API Reference","title":"MCP2221Driver.ReferenceVoltageOption","text":"Reference voltage configuration for DAC and ADC.\n\nReference4p096: reference is 4.096V (only if VDD is above this voltage)\nReference2p048: reference is 2.048V \nReference1p024: reference is 1.024V\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.SourceReferenceOption","page":"Low-Level API Reference","title":"MCP2221Driver.SourceReferenceOption","text":"Reference voltage for DAC.\n\nSourceReferenceVRM: reference voltage is VRM\nSourceReferenceVDD: reference voltage is VDD\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#IC","page":"Low-Level API Reference","title":"I²C","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.CancellationStatus\nMCP2221Driver.CommunicationSpeedStatus\nMCP2221Driver.I2CFrameMode\nMCP2221Driver.I2CAddress","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.CancellationStatus","page":"Low-Level API Reference","title":"MCP2221Driver.CancellationStatus","text":"Cancellation status after a StatusSetParametersCommand:\n\nNoSpecialOperation  cancel current I²C/SMBus transfer,\nMarkedForCancellation current transferm marked for cancellation, bus release will need some time,\nAlreadyIdle the I²C engine was already in Idle mode.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.CommunicationSpeedStatus","page":"Low-Level API Reference","title":"MCP2221Driver.CommunicationSpeedStatus","text":"Communication speed status after a StatusSetParametersCommand:\n\nNoSetSpeed no new speed was issued,\nNewSpeedConsidered new speed is now considered,\nSpeedNotSet communication speed was not set.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.I2CFrameMode","page":"Low-Level API Reference","title":"MCP2221Driver.I2CFrameMode","text":"I²C Frame mode. Writing and reading on the I²C bus is affected by this enumeration.\n\nI2CSingle\nI2CRepeatedStart\nI2CNoStop\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.I2CAddress","page":"Low-Level API Reference","title":"MCP2221Driver.I2CAddress","text":"Facility container for storing I²C addresses. Users generally should not care about this.\n\nFields\n\naddress::UInt8\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#General-Purpose-pins","page":"Low-Level API Reference","title":"General Purpose pins","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.GPDesignation\nMCP2221Driver.GPDirection\nMCP2221Driver.ClockOutputDutyCycle\nMCP2221Driver.ClockOutputFrequency\nMCP2221Driver.GPIOStatus","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.GPDesignation","page":"Low-Level API Reference","title":"MCP2221Driver.GPDesignation","text":"Enum to set the dedicated function of a GP pin.\n\nGPIOOperation\nDedicatedFunctionOperation\nAlternateFunction0\nAlternateFunction1\nAlternateFunction2\n\nwarning: Not all members available!\nNot all members of the enum are available to all four GP pins. Refer to the following table for a list of available modes:GP pin GPIOOperation DedicatedFunctionOperation AlternateFunction0 AlternateFunction1 AlternateFunction2\nGP0 Available SSPND LED_URx Not Available Not Available\nGP1 Available clock output ADC1 LED_UTx Interrupt detection\nGP2 Available USBCFG ADC2 DAC1 Not Available\nGP3 Available LED_I2C ADC3 DAC2 Not Available\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GPDirection","page":"Low-Level API Reference","title":"MCP2221Driver.GPDirection","text":"Enum to set the direction of a GP pin.\n\nGPIOInput\nGPIOOutput\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ClockOutputDutyCycle","page":"Low-Level API Reference","title":"MCP2221Driver.ClockOutputDutyCycle","text":"Clock output duty cycle for GP1.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ClockOutputFrequency","page":"Low-Level API Reference","title":"MCP2221Driver.ClockOutputFrequency","text":"Clock output frequency for GP1.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GPIOStatus","page":"Low-Level API Reference","title":"MCP2221Driver.GPIOStatus","text":"Store the status of a GPIO.\n\nFields\n\noutputvalue::Bool: Logical value present at the output.\ndirection::MCP2221Driver.GPDirection: GPIO direction.\ndesignation::MCP2221Driver.GPDesignation: GPIO designation. See GPDesignation for a list of available designation for each pin.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#Commands-and-Responses","page":"Low-Level API Reference","title":"Commands and Responses","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.query\nMCP2221Driver.GenericResponse\nMCP2221Driver.StringResponse","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.query","page":"Low-Level API Reference","title":"MCP2221Driver.query","text":"query(dev, command)\n\nBlocking call to the device to send the command and receive the response if one  is expected.\n\n\n\n\n\n","category":"function"},{"location":"lowlevel/reference/#MCP2221Driver.GenericResponse","page":"Low-Level API Reference","title":"MCP2221Driver.GenericResponse","text":"A generic response where only the response status is interesting.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.StringResponse","page":"Low-Level API Reference","title":"MCP2221Driver.StringResponse","text":"A generic response for commands that respond with a string.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\nstring::String: Response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#Chip-configuration-commands-and-responses","page":"Low-Level API Reference","title":"Chip configuration commands and responses","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.StatusSetParametersCommand\nMCP2221Driver.StatusSetParametersResponse\nMCP2221Driver.ResetChipCommand","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.StatusSetParametersCommand","page":"Low-Level API Reference","title":"MCP2221Driver.StatusSetParametersCommand","text":"Poll the status of the device, and establish certain I²C bus parameters/conditions.\n\nMCP2221Driver.StatusSetParametersCommand expects a MCP2221Driver.StatusSetParametersResponse response.\n\nFields\n\ncancelcurrent::Bool: Cancel current I²C/SMBus transfer\ndivider::Int8: Set I²C/SMBus communication speed. If set to 0 don't act. Otherwise the new clock speed is 12 MHz/divider\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.StatusSetParametersResponse","page":"Low-Level API Reference","title":"MCP2221Driver.StatusSetParametersResponse","text":"Response for a StatusSetParametersCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\ncancellationstatus::MCP2221Driver.CancellationStatus: Status of the cancellation request.\nspeedstatus::MCP2221Driver.CommunicationSpeedStatus: Status of the new speed request.\ndivider::UInt8: Divider value for the speed.\nrequestedtransferlength::UInt16: Length of the requested I²C transfer.\nalreadytransferedlength::UInt16: Length of the already transfered I²C message.\ni2cbuffercounter::UInt8: Internal I²C data buffer counter.\ncurrentcommunicationspeeddividervalue::UInt8: Current communication speed divider value.\ncurrenti2ctimeoutvalue::UInt8: Current I²C timeout value.\ncurrenti2caddress::UInt16: Current I²C address.\nackreceived::Bool: If ACK was received from client.\nsclvalue::UInt8: Current SCL line value.\nsdavalue::UInt8: Current SDA line value.\ninteruptedgestate::Bool: Interrupt edge detector state.\ni2creadpendingvalue::UInt8: I²C read pending value.\nhardwareversion::VersionNumber: MCP2221 hardware version.\nfirmwareversion::VersionNumber: MCP2221 firmware version.\nadcdatach0::UInt16: Channel 0 ADC value.\nadcdatach1::UInt16: Channel 1 ADC value.\nadcdatach2::UInt16: Channel 2 ADC value.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ResetChipCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ResetChipCommand","text":"This command is used to force a Reset of the MCP2221A device. This command is  useful when the Flash memory is updated with new data. The MCP2221A would need  to be re-enumerated to see the new data.\n\nMCP2221Driver.ResetChipCommand does not expects a response.\n\nnote: Note\nThis command is the only command that does not expect a response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#Flash-Memory-Manipulation","page":"Low-Level API Reference","title":"Flash Memory Manipulation","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.ReadFlashDataCommand\nMCP2221Driver.ReadFlashDataChipSettingsCommand\nMCP2221Driver.ReadFlashDataChipSettingsResponse\nMCP2221Driver.ReadFlashDataGPSettingsCommand\nMCP2221Driver.ReadFlashDataGPSettingsResponse\nMCP2221Driver.ReadFlashDataUSBManufacturerDescriptorStringCommand\nMCP2221Driver.ReadFlashDataUSBProductDescriptorStringCommand\nMCP2221Driver.ReadFlashDataUSBSerialNumberDescriptorStringCommand\nMCP2221Driver.ReadFlashDataChipFactorySerialNumberCommand\nMCP2221Driver.ReadFlashDataChipFactorySerialNumberResponse\nMCP2221Driver.WriteFlashDataCommand\nMCP2221Driver.WriteFlashDataChipSettingsCommand\nMCP2221Driver.WriteFlashDataGPSettingsCommand\nMCP2221Driver.WriteFlashStringCommand\nMCP2221Driver.WriteFlashDataUSBManufacturerDescriptorStringCommand\nMCP2221Driver.WriteFlashDataUSBProductDescriptorStringCommand\nMCP2221Driver.WriteFlashDataUSBSerialNumberDescriptorStringCommand\nMCP2221Driver.SendFlashAccessPasswordCommand","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataCommand","text":"Main type for reading the flash memory.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataChipSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataChipSettingsCommand","text":"Read chip settings from flash memory.\n\nMCP2221Driver.ReadFlashDataChipSettingsCommand expects a MCP2221Driver.ReadFlashDataChipSettingsResponse response. See also WriteFlashDataChipSettingsCommand.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataChipSettingsResponse","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataChipSettingsResponse","text":"Response for a ReadFlashDataChipSettingsCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\ncdcserialnumberenumerationenable::Bool: If true, the USB serial number will be used during the USB enumeration of the CDC interface.\nchipconfigurationsecurityoption::MCP2221Driver.ChipConfigurationSecurityOption: Chip configuration security option.\nclockoutputduty::MCP2221Driver.ClockOutputDutyCycle: If the GP pin is enabled for clock output operations, this is the duty cycle of the output.\nclockoutputdividervalue::MCP2221Driver.ClockOutputFrequency: If the GP pin is enabled for clock output operations, the divider value will be used on the 48MHz US internal clock and the divider output will be sent to this pin.\ndacreferencevoltage::MCP2221Driver.ReferenceVoltageOption: DAC reference voltage option.\ndacreferenceoption::MCP2221Driver.SourceReferenceOption: DAC reference option.\npowerupdacvalue::UInt8: Power-up DAC value.\ninterruptdetectionnegativeedge::Bool: If true, the interrupt detection flag will be set when a negative edge occurs.\ninterruptdetectionpositiveedge::Bool: If true, the interrupt detection flag will be set when a positive edge occurs.\nadcreferencevoltage::MCP2221Driver.ReferenceVoltageOption: ADC reference voltage.\nadcreferenceoption::MCP2221Driver.SourceReferenceOption: ADC reference option.\nvid::UInt16: USB VID value.\npid::UInt16: USB PID value.\nusbpowerattributes::UInt8: USB power attribute as per USB 2.0 specification.\nusbrequestednumberofma::UInt8: USB requested number of mA(s) as per USB 2.0 specification.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataGPSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataGPSettingsCommand","text":"Read GP settings from flash memory.\n\nMCP2221Driver.ReadFlashDataGPSettingsCommand expects a MCP2221Driver.ReadFlashDataGPSettingsResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataGPSettingsResponse","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataGPSettingsResponse","text":"Response for a ReadFlashDataGPSettingsCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\ngpio0powerupstatus::MCP2221Driver.GPIOStatus: GPIO0 status at power-up.\ngpio1powerupstatus::MCP2221Driver.GPIOStatus: GPIO1 status at power-up.\ngpio2powerupstatus::MCP2221Driver.GPIOStatus: GPIO2 status at power-up.\ngpio3powerupstatus::MCP2221Driver.GPIOStatus: GPIO3 status at power-up.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataUSBManufacturerDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataUSBManufacturerDescriptorStringCommand","text":"Read USB manufacturer string descriptor used during USB enumeration from flash memory.\n\nMCP2221Driver.ReadFlashDataUSBManufacturerDescriptorStringCommand expects a MCP2221Driver.StringResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataUSBProductDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataUSBProductDescriptorStringCommand","text":"Read USB product string descriptor used during USB enumeration from flash memory.\n\nMCP2221Driver.ReadFlashDataUSBProductDescriptorStringCommand expects a MCP2221Driver.StringResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataUSBSerialNumberDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataUSBSerialNumberDescriptorStringCommand","text":"Read USB serial number used during USB enumeration from flash memory.\n\nMCP2221Driver.ReadFlashDataUSBSerialNumberDescriptorStringCommand expects a MCP2221Driver.StringResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataChipFactorySerialNumberCommand","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataChipFactorySerialNumberCommand","text":"Read chip factory serial number from flash memory. Cannot be changed.\n\nMCP2221Driver.ReadFlashDataChipFactorySerialNumberCommand expects a MCP2221Driver.ReadFlashDataChipFactorySerialNumberResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.ReadFlashDataChipFactorySerialNumberResponse","page":"Low-Level API Reference","title":"MCP2221Driver.ReadFlashDataChipFactorySerialNumberResponse","text":"Response for a ReadFlashDataChipFactorySerialNumberCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\nnumber::Vector{UInt8}: Chip factory serial number, typically 8 bytes long.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataCommand","text":"Abstract supertype for all flash writing operations. Used internally because the MCP2221 actually have only one command divided in sub-commands for this.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataChipSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataChipSettingsCommand","text":"Write chip settings into Flash memory.\n\nMCP2221Driver.WriteFlashDataChipSettingsCommand expects a MCP2221Driver.GenericResponse response. See also ReadFlashDataChipSettingsCommand.\n\nFields\n\ncdcserialnumberenumerationenable::Bool: If true, the USB serial number will be used during the USB enumeration of the CDC interface.\nchipconfigurationsecurityoption::MCP2221Driver.ChipConfigurationSecurityOption: Chip configuration security option.\nclockoutputduty::MCP2221Driver.ClockOutputDutyCycle: If the GP pin is enabled for clock output operations, this is the duty cycle of the output.\nclockoutputdividervalue::MCP2221Driver.ClockOutputFrequency: If the GP pin is enabled for clock output operations, the divider value will be used on the 48MHz US internal clock and the divider output will be sent to this pin.\ndacreferencevoltage::MCP2221Driver.ReferenceVoltageOption: DAC reference voltage option.\ndacreferenceoption::MCP2221Driver.SourceReferenceOption: DAC reference option.\npowerupdacvalue::UInt8: Power-up DAC value.\ninterruptdetectionnegativeedge::Bool: If true, the interrupt detection flag will be set when a negative edge occurs.\ninterruptdetectionpositiveedge::Bool: If true, the interrupt detection flag will be set when a positive edge occurs.\nadcreferencevoltage::MCP2221Driver.ReferenceVoltageOption: ADC reference voltage.\nadcreferenceoption::MCP2221Driver.SourceReferenceOption: ADC reference option.\nvid::UInt16: USB VID value.\npid::UInt16: USB PID value.\nusbpowerattributes::UInt8: USB power attribute as per USB 2.0 specification.\nusbrequestednumberofma::UInt8: USB requested number of mA(s) as per USB 2.0 specification.\npassword::String: 8-byte password (for Flash modifications protection).\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataGPSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataGPSettingsCommand","text":"Write GP settings into Flash memory.\n\nMCP2221Driver.WriteFlashDataGPSettingsCommand expects a MCP2221Driver.GenericResponse response.  ReadFlashDataGPSettingsCommand.\n\nFields\n\ngpio0powerupstatus::MCP2221Driver.GPIOStatus: GPIO0 status at power-up.\ngpio1powerupstatus::MCP2221Driver.GPIOStatus: GPIO1 status at power-up.\ngpio2powerupstatus::MCP2221Driver.GPIOStatus: GPIO2 status at power-up.\ngpio3powerupstatus::MCP2221Driver.GPIOStatus: GPIO3 status at power-up.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashStringCommand","text":"Abstract super-type for all commands writing a string to flash memory. The  subtypes are expected to expose a string attribute.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataUSBManufacturerDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataUSBManufacturerDescriptorStringCommand","text":"Write USB manufacturer descriptor string into Flash memory.\n\nMCP2221Driver.WriteFlashDataUSBManufacturerDescriptorStringCommand expects a MCP2221Driver.GenericResponse response. See also ReadFlashDataUSBManufacturerDescriptorStringCommand.\n\nFields\n\nstring::String\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataUSBProductDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataUSBProductDescriptorStringCommand","text":"Write USB product descriptor string into Flash memory.\n\nMCP2221Driver.WriteFlashDataUSBProductDescriptorStringCommand expects a MCP2221Driver.GenericResponse response. See also ReadFlashDataUSBProductDescriptorStringCommand.\n\nFields\n\nstring::String\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.WriteFlashDataUSBSerialNumberDescriptorStringCommand","page":"Low-Level API Reference","title":"MCP2221Driver.WriteFlashDataUSBSerialNumberDescriptorStringCommand","text":"Write USB serial number descriptor string into Flash memory.\n\nMCP2221Driver.WriteFlashDataUSBSerialNumberDescriptorStringCommand expects a MCP2221Driver.GenericResponse response. See also ReadFlashDataUSBSerialNumberDescriptorStringCommand.\n\nFields\n\nstring::String\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.SendFlashAccessPasswordCommand","page":"Low-Level API Reference","title":"MCP2221Driver.SendFlashAccessPasswordCommand","text":"Send user-supplied password that will be compared to the one stored in the device's  Flash when Flash updates are required and the Flash data are password-protected.\n\nThe password must be at most 8 bytes long. If your string contains characters more than one byte long, their LSB will be written first.\n\nMCP2221Driver.SendFlashAccessPasswordCommand expects a MCP2221Driver.GenericResponse response.\n\nFields\n\npassword::AbstractString: 8-bytes of password.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#SRAM-Manipulation","page":"Low-Level API Reference","title":"SRAM Manipulation","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.SetSRAMSettingsCommand\nMCP2221Driver.GetSRAMSettingsCommand\nMCP2221Driver.GetSRAMSettingsResponse","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.SetSRAMSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.SetSRAMSettingsCommand","text":"This command is used to al,er various run-time Chip settings. The altered  settings reside in SRAM me,ory and they will not affect the Chip’s  power-up/Reset default settings. These altered settings will be active until  the next chip power-up/Reset.\n\nMCP2221Driver.SetSRAMSettingsCommand expects a MCP2221Driver.GenericResponse response.\n\nFields\n\nclockoutputsettings::Union{Nothing, @NamedTuple{duty::MCP2221Driver.ClockOutputDutyCycle, dividervalue::MCP2221Driver.ClockOutputFrequency}}: If the GP pin is enabled for clock output operations, these are the duty  cycle and the output frequency.\n\ndacsettings::Union{Nothing, @NamedTuple{referencevoltage::MCP2221Driver.ReferenceVoltageOption, referenceoption::MCP2221Driver.SourceReferenceOption}}: DAC settings.\ndacoutputvalue::Union{Nothing, UInt8}: DAC output value, only the 5 LSB are taken into account.\nadcsettings::Union{Nothing, @NamedTuple{referencevoltage::MCP2221Driver.ReferenceVoltageOption, referenceoption::MCP2221Driver.SourceReferenceOption}}: ADC settings.\ninterruptdetectionpositiveedge::Union{Nothing, Bool}: If set to a boolean value, control wether interrupt detection will trigger on positive edges.\ninterruptdetectionnegativeedge::Union{Nothing, Bool}: If set to a boolean value, control wether interrupt detection will trigger on negative edges.\nclearinterrupt::Bool: If set to true, clear the interrupt flag. Default is false.\ngpiosettings::Union{Nothing, @NamedTuple{gpio0::MCP2221Driver.GPIOStatus, gpio1::MCP2221Driver.GPIOStatus, gpio2::MCP2221Driver.GPIOStatus, gpio3::MCP2221Driver.GPIOStatus}}: If set, change GPIO settings. For more fine-grained control, see SetGPIOOutputValuesCommand.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetSRAMSettingsCommand","page":"Low-Level API Reference","title":"MCP2221Driver.GetSRAMSettingsCommand","text":"This command is used to retrieve the run-time Chip and GP settings.\n\nMCP2221Driver.GetSRAMSettingsCommand expects a MCP2221Driver.GetSRAMSettingsResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetSRAMSettingsResponse","page":"Low-Level API Reference","title":"MCP2221Driver.GetSRAMSettingsResponse","text":"Response to a GetSRAMSettingsCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\nlengthchipsettings::UInt8: Length in bytes of the SRAM Chip settings area.\nlengthgpsettings::UInt8: Length in bytes of the SRAM GP settings area.\ncdcserialnumberenumerationenable::Bool: If true, the USB serial number will be used during the USB enumeration of the CDC interface.\nchipconfigurationsecurityoption::MCP2221Driver.ChipConfigurationSecurityOption: Chip configuration security option.\nclockoutputduty::MCP2221Driver.ClockOutputDutyCycle: If the GP pin is enabled for clock output operations, this is the duty cycle of the output.\nclockoutputdividervalue::MCP2221Driver.ClockOutputFrequency: If the GP pin is enabled for clock output operations, the divider value will be used on the 48MHz US internal clock and the divider output will be sent to this pin.\ndacreferencevoltage::MCP2221Driver.ReferenceVoltageOption: DAC reference voltage option.\ndacreferenceoption::MCP2221Driver.SourceReferenceOption: DAC reference option.\npowerupdacvalue::UInt8: Power-up DAC value.\ninterruptdetectionnegativeedge::Bool: If true, the interrupt detection flag will be set when a negative edge occurs.\ninterruptdetectionpositiveedge::Bool: If true, the interrupt detection flag will be set when a positive edge occurs.\nadcreferencevoltage::MCP2221Driver.ReferenceVoltageOption: ADC reference voltage.\nadcreferenceoption::MCP2221Driver.SourceReferenceOption: ADC reference option.\nvid::UInt16: USB VID value.\npid::UInt16: USB PID value.\nusbpowerattributes::UInt8: USB power attribute as per USB 2.0 specification.\nusbrequestednumberofma::UInt8: USB requested number of mA(s) as per USB 2.0 specification.\npassword::String: Current Supplied Password (8 bytes).\ngpio0status::MCP2221Driver.GPIOStatus: GPIO0 status.\ngpio1status::MCP2221Driver.GPIOStatus: GPIO1 status.\ngpio2status::MCP2221Driver.GPIOStatus: GPIO2 status.\ngpio3status::MCP2221Driver.GPIOStatus: GPIO3 status.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#IC-Communications","page":"Low-Level API Reference","title":"I²C Communications","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.I2CWriteDataCommand\nMCP2221Driver.I2CReadDataCommand\nMCP2221Driver.GetI2CDataCommand\nMCP2221Driver.GetI2CDataResponse","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.I2CWriteDataCommand","page":"Low-Level API Reference","title":"MCP2221Driver.I2CWriteDataCommand","text":"Write data on the I²C bus. Depending on the chosen I2CFrameMode, the  behavior will vary. The command has the following effects:\n\nSend the \"Start\" (I2CSingle, I2CNoStop) or \"RepeatedStart\" (I2CRepeatedStart) condition.\nSend the I²C client address and wait for the client to send an Acknowledge bit.\nThe user data follow next. The I²C engine waits for the Acknowledge bit from the client.\nIf the requested length is more than 60 bytes, subsequent user bytes will be sent on the bus.\nWhen the user data length reaches the requested length, the I²C engine will send the \"Stop\" condition on the bus, except when the mode is I2CNoStop.\n\nNote that you can send data longer than 60 bytes by repeating the command, but this layer will not take care of that for you and will error if your data is longer than 60 bytes.\n\nMCP2221Driver.I2CWriteDataCommand expects a MCP2221Driver.GenericResponse response.\n\nFields\n\naddress::MCP2221Driver.I2CAddress\nwritemode::MCP2221Driver.I2CFrameMode\ndata::Vector{UInt8}\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.I2CReadDataCommand","page":"Low-Level API Reference","title":"MCP2221Driver.I2CReadDataCommand","text":"Read data from the I²C bus. Depending on the chosen I2CFrameMode, the  behavior will vary. Note that the I2CNoStop mode is not supported. The command  has the following effects:\n\nSend the \"Start\" (I2CSingle) or \"RepeatedStart\" (I2CRepeatedStart) condition.\nSend the I²C client address and wait for the client to send an Acknowledge bit.\nThe user data follow next. The I²C engine sends the Acknowledge bit to the client.\nIf the requested length is more than 60 bytes, subsequent user bytes will be read from the bus.\nWhen the user data length reaches the requested length, the I²C engine will send the \"Stop\" condition on the bus.\n\nMCP2221Driver.I2CReadDataCommand expects a MCP2221Driver.GenericResponse response.\n\nFields\n\naddress::MCP2221Driver.I2CAddress\nreadmode::MCP2221Driver.I2CFrameMode\nlength::UInt16\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetI2CDataCommand","page":"Low-Level API Reference","title":"MCP2221Driver.GetI2CDataCommand","text":"This command is used to read back the data from the I2C client device.\n\nMCP2221Driver.GetI2CDataCommand expects a MCP2221Driver.GetI2CDataResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetI2CDataResponse","page":"Low-Level API Reference","title":"MCP2221Driver.GetI2CDataResponse","text":"Response to a GetI2CDataCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\ndata::Vector{UInt8}\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#GPIO-Manipulation","page":"Low-Level API Reference","title":"GPIO Manipulation","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"MCP2221Driver.SetGPIOOutputValuesCommand\nMCP2221Driver.GetGPIOValuesCommand\nMCP2221Driver.GetGPIOValuesResponse","category":"page"},{"location":"lowlevel/reference/#MCP2221Driver.SetGPIOOutputValuesCommand","page":"Low-Level API Reference","title":"MCP2221Driver.SetGPIOOutputValuesCommand","text":"This command is used to change the GPIO output value for those GP pins assigned  for GPIO operation (GPIO outputs).\n\nMCP2221Driver.SetGPIOOutputValuesCommand expects a MCP2221Driver.GenericResponse response.\n\nFields\n\ngp0outputvalue::Union{Nothing, Bool}: GP0 output value, set to nothing to leave unchanged.\ngp0pindirection::Union{Nothing, Bool}: GP0 pin direction, set to nothing to leave unchanged, false for output, true for input.\ngp1outputvalue::Union{Nothing, Bool}: GP1 output value, set to nothing to leave unchanged.\ngp1pindirection::Union{Nothing, Bool}: GP1 pin direction, set to nothing to leave unchanged, false for output, true for input.\ngp2outputvalue::Union{Nothing, Bool}: GP2 output value, set to nothing to leave unchanged.\ngp2pindirection::Union{Nothing, Bool}: GP2 pin direction, set to nothing to leave unchanged, false for output, true for input.\ngp3outputvalue::Union{Nothing, Bool}: GP3 output value, set to nothing to leave unchanged.\ngp3pindirection::Union{Nothing, Bool}: GP3 pin direction, set to nothing to leave unchanged, false for output, true for input.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetGPIOValuesCommand","page":"Low-Level API Reference","title":"MCP2221Driver.GetGPIOValuesCommand","text":"This command is used to retrieve the GPIO direction and pin value for those GP  pins assigned for GPIO operation (GPIO inputs or outputs).\n\nMCP2221Driver.GetGPIOValuesCommand expects a MCP2221Driver.GetGPIOValuesResponse response.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#MCP2221Driver.GetGPIOValuesResponse","page":"Low-Level API Reference","title":"MCP2221Driver.GetGPIOValuesResponse","text":"Response to a GetGPIOValuesCommand.\n\nFields\n\nstatus::MCP2221Driver.ResponseStatus: See ResponseStatus.\ngp0pinvalue::Union{Nothing, Bool}: GP0 logic pin value, or nothing if not set for GPIO operations.\ngp0directionvalue::Union{Nothing, Bool}: GP0 pin designation (false for output true for input), or nothing if not set for GPIO operations.\ngp1pinvalue::Union{Nothing, Bool}: GP1 logic pin value, or nothing if not set for GPIO operations.\ngp1directionvalue::Union{Nothing, Bool}: GP1 pin designation (false for output true for input), or nothing if not set for GPIO operations.\ngp2pinvalue::Union{Nothing, Bool}: GP2 logic pin value, or nothing if not set for GPIO operations.\ngp2directionvalue::Union{Nothing, Bool}: GP2 pin designation (false for output true for input), or nothing if not set for GPIO operations.\ngp3pinvalue::Union{Nothing, Bool}: GP3 logic pin value, or nothing if not set for GPIO operations.\ngp3directionvalue::Union{Nothing, Bool}: GP3 pin designation (false for output true for input), or nothing if not set for GPIO operations.\n\n\n\n\n\n","category":"type"},{"location":"lowlevel/reference/#Index","page":"Low-Level API Reference","title":"Index","text":"","category":"section"},{"location":"lowlevel/reference/","page":"Low-Level API Reference","title":"Low-Level API Reference","text":"Pages   = [\"reference.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MCP2221Driver","category":"page"},{"location":"#MCP2221Driver","page":"Home","title":"MCP2221Driver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MCP2221Driver.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"lowlevel/#Low-Level-API","page":"Low-Level API","title":"Low-Level API","text":"","category":"section"},{"location":"lowlevel/","page":"Low-Level API","title":"Low-Level API","text":"MCP2221Driver.jl exposes a low-level API that roughly maps the raw HID commands supported by the chip. This aims at giving you the highest level possible of control over the hardware.","category":"page"},{"location":"lowlevel/","page":"Low-Level API","title":"Low-Level API","text":"Pages = [\"index.md\", \"tutorial.md\", \"reference.md\", \"internal.md\"]\nDepth = 2","category":"page"}]
}
